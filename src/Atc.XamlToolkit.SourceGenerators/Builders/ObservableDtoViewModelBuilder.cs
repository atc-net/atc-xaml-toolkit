namespace Atc.XamlToolkit.SourceGenerators.Builders;

internal sealed class ObservableDtoViewModelBuilder : CommandBuilderBase
{
    public void GenerateStart(
        ObservableDtoViewModelToGenerate viewModelToGenerate)
    {
        AppendLine("// <auto-generated>");
        AppendLine("#nullable enable");

        // Add using for commands if needed
        if (viewModelToGenerate.CustomCommands.Count > 0)
        {
            AppendLine("using Atc.XamlToolkit.Command;");
        }

        AppendLine();
        AppendLine($"namespace {viewModelToGenerate.NamespaceName};");
        AppendLine();
        AppendLine($"{viewModelToGenerate.ClassAccessModifier} partial class {viewModelToGenerate.ClassName}");
        AppendLine("{");
        IncreaseIndent();
    }

    public void GenerateDtoFieldAndCommandBackingFields(
        ObservableDtoViewModelToGenerate viewModelToGenerate)
    {
        var hasAnyRecordParameter = viewModelToGenerate.Properties.Any(p => p.IsRecordParameter);
        var readonlyModifier = !viewModelToGenerate.IsDtoRecord || !hasAnyRecordParameter
            ? "readonly "
            : string.Empty;

        AppendLine($"private {readonlyModifier}{viewModelToGenerate.DtoTypeName} dto;");

        // Generate backing fields for commands
        if (viewModelToGenerate.CustomCommands.Count > 0)
        {
            AppendLine();
            foreach (var cmd in viewModelToGenerate.CustomCommands)
            {
                var interfaceType = cmd.GetInterfaceType();
                var generic = cmd.GetGenericArgAsString();
                var fieldName = cmd.GetCommandAsFieldName();
                AppendLine($"private {interfaceType}{generic}? {fieldName};");
            }
        }
    }

    public void GenerateConstructor(
        ObservableDtoViewModelToGenerate viewModelToGenerate)
    {
        AppendLine();
        AppendLine($"public {viewModelToGenerate.ClassName}({viewModelToGenerate.DtoTypeName} dto)");
        AppendLine("{");
        IncreaseIndent();
        AppendLine("this.dto = dto;");

        // Generate InitializeValidation call if any validation is enabled
        if (viewModelToGenerate.EnableValidationOnPropertyChanged || viewModelToGenerate.EnableValidationOnInit)
        {
            AppendLine();
            AppendLine("InitializeValidation(");
            IncreaseIndent();
            AppendLine($"validateOnPropertyChanged: {viewModelToGenerate.EnableValidationOnPropertyChanged.ToString().ToLowerInvariant()},");
            AppendLine($"validateAllPropertiesOnInit: {viewModelToGenerate.EnableValidationOnInit.ToString().ToLowerInvariant()});");
            DecreaseIndent();
        }

        DecreaseIndent();
        AppendLine("}");
    }

    public void GenerateInnerModelProperty(
        ObservableDtoViewModelToGenerate viewModelToGenerate)
    {
        AppendLine();
        AppendLine($"public {viewModelToGenerate.DtoTypeName} InnerModel => dto;");
    }

    public void GenerateProperties(
        ObservableDtoViewModelToGenerate viewModelToGenerate)
    {
        foreach (var property in viewModelToGenerate.Properties)
        {
            AppendLine();

            // Generate attributes if any
            foreach (var attribute in property.Attributes)
            {
                AppendLine($"[{attribute}]");
            }

            if (property.IsReadOnly)
            {
                // Generate readonly property (getter only)
                AppendLine($"public {property.Type} {property.Name} => dto.{property.Name};");
            }
            else
            {
                // Generate full property with getter and setter
                AppendLine($"public {property.Type} {property.Name}");
                AppendLine("{");
                IncreaseIndent();
                AppendLine($"get => dto.{property.Name};");
                AppendLine("set");
                AppendLine("{");
                IncreaseIndent();
                AppendLine($"if (dto.{property.Name} == value)");
                AppendLine("{");
                IncreaseIndent();
                AppendLine("return;");
                DecreaseIndent();
                AppendLine("}");
                AppendLine();

                AppendLine(property.IsRecordParameter
                    ? $"dto = dto with {{ {property.Name} = value }};"
                    : $"dto.{property.Name} = value;");

                AppendLine($"RaisePropertyChanged(nameof({property.Name}));");

                // Raise property changed for computed properties that depend on this property
                foreach (var computedProperty in viewModelToGenerate.ComputedProperties)
                {
                    if (computedProperty.DependentPropertyNames.Contains(property.Name, StringComparer.Ordinal))
                    {
                        AppendLine($"RaisePropertyChanged(nameof({computedProperty.Name}));");
                    }
                }

                if (viewModelToGenerate.UseIsDirty)
                {
                    AppendLine("IsDirty = true;");
                }

                DecreaseIndent();
                AppendLine("}");
                DecreaseIndent();
                AppendLine("}");
            }
        }
    }

    public void GenerateMethods(
        ObservableDtoViewModelToGenerate viewModelToGenerate)
    {
        foreach (var method in viewModelToGenerate.Methods)
        {
            AppendLine();

            var parameters = string.Join(", ", method.Parameters.Select(p => $"{p.Type} {p.Name}"));
            var arguments = string.Join(", ", method.Parameters.Select(p => p.Name));

            AppendLine($"public {method.ReturnType} {method.Name}({parameters})");
            AppendLine($"    => dto.{method.Name}({arguments});");
        }
    }

    public void GenerateCustomCommandProperties(
        ObservableDtoViewModelToGenerate viewModelToGenerate)
    {
        if (viewModelToGenerate.CustomCommands.Count == 0)
        {
            return;
        }

        AppendLine();

        var commands = viewModelToGenerate.CustomCommands.ToArray();
        for (var i = 0; i < commands.Length; i++)
        {
            var cmd = commands[i];
            var interfaceType = cmd.GetInterfaceType();
            var implementationType = cmd.GetImplementationType();
            var generic = cmd.GetGenericArgAsString();
            var propName = cmd.GetCommandAsPropertyName();
            var fieldName = cmd.GetCommandAsFieldName();
            var execExpr = BuildExecuteExpression(cmd);
            var canExecExpr = BuildCanExecuteExpression(cmd);
            var hasCan = canExecExpr is not null;
            var appendAsMultiLine = hasCan ||
                                    cmd.ExecuteOnBackgroundThread ||
                                    cmd.AutoSetIsBusy;

            if (appendAsMultiLine)
            {
                AppendLine($"public {interfaceType}{generic} {propName} => {fieldName} ??= new {implementationType}{generic}(");
                IncreaseIndent();

                if (cmd.AutoSetIsBusy)
                {
                    AppendAutoSetIsBusyBlock(
                        this,
                        cmd,
                        execExpr,
                        hasCan);
                }
                else
                {
                    var suffix = hasCan ? "," : ");";
                    AppendLine($"{execExpr}{suffix}");
                }

                if (hasCan)
                {
                    AppendLine($"{canExecExpr});");
                }

                DecreaseIndent();
            }
            else
            {
                AppendLine($"public {interfaceType}{generic} {propName} => {fieldName} ??= new {implementationType}{generic}({execExpr});");
            }
        }
    }

    private static string BuildExecuteExpression(RelayCommandToGenerate cmd)
    {
        if (cmd.ParameterValues?.Length > 0)
        {
            var parameterValuesAsCommaSeparated = cmd.GetParameterValuesAsCommaSeparated();
            return cmd is { ExecuteOnBackgroundThread: true, UseTask: true }
                ? $"() => Task.Run(() => {cmd.MethodName}({parameterValuesAsCommaSeparated}))"
                : $"() => {cmd.MethodName}({parameterValuesAsCommaSeparated})";
        }

        var filteredParameterTypes = cmd.GetParameterTypesWithoutCancellationToken();
        var hasCt = cmd.HasParameterTypesOfCancellationToken();

        if (filteredParameterTypes.Length > 0)
        {
            if (filteredParameterTypes.Length == 1)
            {
                if (cmd.ExecuteOnBackgroundThread)
                {
                    var paramCall = hasCt
                        ? $"(x, {NameConstants.CancellationTokenNone})"
                        : "(x)";

                    return $"x => Task.Run(() => {cmd.MethodName}{paramCall})";
                }

                return hasCt
                    ? $"x => {cmd.MethodName}(x, {NameConstants.CancellationTokenNone})"
                    : cmd.MethodName;
            }

            var args = cmd.GetParameterTypesWithoutCancellationTokenAsItemNumberArgsAsCommaSeparated();

            var call = hasCt
                ? $"({args}, {NameConstants.CancellationTokenNone})"
                : $"({args})";

            return cmd.ExecuteOnBackgroundThread
                ? $"Task.Run(() => {cmd.MethodName}{call})"
                : $"x => {cmd.MethodName}{call}";
        }

        if (cmd.ExecuteOnBackgroundThread)
        {
            return hasCt
                ? $"() => Task.Run(() => {cmd.MethodName}({NameConstants.CancellationTokenNone}))"
                : $"() => Task.Run({cmd.MethodName})";
        }

        return hasCt
            ? $"() => {cmd.MethodName}({NameConstants.CancellationTokenNone})"
            : cmd.MethodName;
    }

    [SuppressMessage("Design", "MA0051:Method is too long", Justification = "OK - Matches CommandBuilderBase.BuildCanExecuteExpression")]
    private static string? BuildCanExecuteExpression(RelayCommandToGenerate cmd)
    {
        if (string.IsNullOrWhiteSpace(cmd.CanExecuteName))
        {
            return null;
        }

        if (cmd.ParameterValues?.Length > 0)
        {
            return $"{cmd.CanExecuteName}({cmd.GetParameterValuesAsCommaSeparated()})";
        }

        var types = cmd.ParameterTypes ?? [];
        var paramCount = types.Length;
        var isCancellationOnly = paramCount == 1 &&
                                 types[0].EndsWith(NameConstants.CancellationToken, StringComparison.Ordinal);

        var filteredParameterTypes = cmd.GetParameterTypesWithoutCancellationToken();

        string? expr;
        if (cmd.UsePropertyForCanExecute)
        {
            if (paramCount == 0 || isCancellationOnly)
            {
                expr = cmd.InvertCanExecute
                    ? $"() => !{cmd.CanExecuteName}"
                    : $"() => {cmd.CanExecuteName}";
            }
            else if (paramCount == 1)
            {
                expr = cmd.InvertCanExecute
                    ? $"_ => !{cmd.CanExecuteName}"
                    : $"_ => {cmd.CanExecuteName}";
            }
            else
            {
                expr = cmd.InvertCanExecute
                    ? $"x => !{cmd.CanExecuteName}"
                    : $"x => {cmd.CanExecuteName}";
            }
        }
        else
        {
            switch (filteredParameterTypes.Length)
            {
                case 1:
                    expr = cmd.InvertCanExecute
                        ? $"!{cmd.CanExecuteName}"
                        : cmd.CanExecuteName;
                    break;
                case > 1:
                {
                    var args = cmd.GetParameterTypesWithoutCancellationTokenAsItemNumberArgsAsCommaSeparated();

                    expr = cmd.InvertCanExecute
                        ? $"x => !{cmd.CanExecuteName}({args})"
                        : $"x => {cmd.CanExecuteName}({args})";
                    break;
                }

                default:
                    expr = cmd.InvertCanExecute
                        ? $"!{cmd.CanExecuteName}"
                        : cmd.CanExecuteName;
                    break;
            }
        }

        return expr;
    }

    [SuppressMessage("Design", "MA0051:Method is too long", Justification = "OK - Matches CommandBuilderBase.AppendAutoSetIsBusyBlock")]
    private static void AppendAutoSetIsBusyBlock(
        ObservableDtoViewModelBuilder builder,
        RelayCommandToGenerate cmd,
        string execExpr,
        bool hasCan)
    {
        var hasExecExprCancellationTokenNone = execExpr.Contains(NameConstants.CancellationTokenNone);

        var useAsyncLambda = hasExecExprCancellationTokenNone ||
                             cmd.GetParameterTypesWithoutCancellationToken().Length > 0 ||
                             execExpr.StartsWith("Task.Run(", StringComparison.Ordinal);

        var execExprContainParameters = execExpr.Contains("(x)") ||
                                        execExpr.Contains("(x, ") ||
                                        execExpr.Contains("(x.");

        var useAwait = false;
        var useDispatcherInvokeAsync = false;
        var useDispatcherInvoke = false;
        switch (cmd.UseTask)
        {
            case false:
                builder.AppendLine(
                    execExprContainParameters
                        ? "x =>"
                        : "() =>");
                useDispatcherInvoke = true;
                break;
            case true when execExprContainParameters:
                builder.AppendLine("async x =>");
                useAwait = true;
                useDispatcherInvokeAsync = true;
                break;
            case true when useAsyncLambda:
            case true when cmd.IsAsync:
                builder.AppendLine("async () =>");
                useAwait = true;
                useDispatcherInvokeAsync = true;
                break;
            case true when !execExprContainParameters ||
                           !execExpr.StartsWith("Task.Run(", StringComparison.Ordinal) ||
                           !execExpr.StartsWith("() => ", StringComparison.Ordinal):
                builder.AppendLine("async () =>");
                useDispatcherInvokeAsync = true;
                break;
        }

        builder.AppendLine("{");
        builder.IncreaseIndent();
        if (useDispatcherInvokeAsync)
        {
            builder.AppendLine("await Application.Current.Dispatcher");
            builder.IncreaseIndent();
            builder.AppendLine(".InvokeAsyncIfRequired(() => IsBusy = true)");
            builder.AppendLine(".ConfigureAwait(false);");
            builder.DecreaseIndent();
        }
        else if (useDispatcherInvoke)
        {
            builder.AppendLine("Application.Current.Dispatcher.InvokeIfRequired(() => IsBusy = true);");
        }
        else
        {
            builder.AppendLine("IsBusy = true;");
        }

        builder.AppendLine();
        builder.AppendLine("try");
        builder.AppendLine("{");
        builder.IncreaseIndent();

        if (cmd.UseTask)
        {
            if (useAwait &&
                !execExpr.StartsWith("Task.Run(", StringComparison.Ordinal) &&
                !execExpr.StartsWith("() => ", StringComparison.Ordinal))
            {
                if (execExpr.StartsWith("x => ", StringComparison.Ordinal))
                {
                    execExpr = execExpr.Replace("x => ", string.Empty);
                }

                builder.AppendLine(
                    execExpr.EndsWith(")", StringComparison.Ordinal)
                        ? $"await {execExpr}.ConfigureAwait(false);"
                        : $"await {execExpr}().ConfigureAwait(false);");
            }
            else
            {
                builder.AppendLine("await Task");
                builder.IncreaseIndent();
                builder.AppendLine($".Run({execExpr.RemoveTaskDotRun()})");
                builder.AppendLine(".ConfigureAwait(false);");
                builder.DecreaseIndent();
            }
        }
        else
        {
            if (execExpr.StartsWith("Task.Run(", StringComparison.Ordinal))
            {
                builder.AppendLine("_ = Task");
                builder.IncreaseIndent();
                builder.AppendLine($".Run({execExpr.RemoveTaskDotRun()})");
                builder.AppendLine(".ConfigureAwait(false);");
                builder.DecreaseIndent();
            }
            else
            {
                builder.AppendLine($"{execExpr};");
            }
        }

        builder.DecreaseIndent();
        builder.AppendLine("}");
        builder.AppendLine("finally");
        builder.AppendLine("{");
        builder.IncreaseIndent();
        if (useDispatcherInvokeAsync)
        {
            builder.AppendLine("await Application.Current.Dispatcher");
            builder.IncreaseIndent();
            builder.AppendLine(".InvokeAsyncIfRequired(() => IsBusy = false)");
            builder.AppendLine(".ConfigureAwait(false);");
            builder.DecreaseIndent();
        }
        else if (useDispatcherInvoke)
        {
            builder.AppendLine("Application.Current.Dispatcher.InvokeIfRequired(() => IsBusy = false);");
        }
        else
        {
            builder.AppendLine("IsBusy = false;");
        }

        builder.DecreaseIndent();
        builder.AppendLine("}");
        builder.DecreaseIndent();
        builder.AppendLine(hasCan ? "}," : "});");
    }

    public void GenerateCustomProperties(
        ObservableDtoViewModelToGenerate viewModelToGenerate)
    {
        if (viewModelToGenerate.CustomProperties.Count == 0)
        {
            return;
        }

        var isFirst = true;
        foreach (var propertyToGenerate in viewModelToGenerate.CustomProperties)
        {
            GenerateCustomProperty(propertyToGenerate, viewModelToGenerate.UseIsDirty, isFirst);
            isFirst = false;
        }
    }

    [SuppressMessage("Design", "MA0051:Method is too long", Justification = "OK - Matches ViewModelBuilderExtensions.GenerateProperty")]
    private void GenerateCustomProperty(
        ObservablePropertyToGenerate p,
        bool useIsDirty,
        bool isFirstProperty)
    {
        if (isFirstProperty)
        {
            AppendLine();
        }
        else
        {
            AppendLineBeforeMember();
        }

        AppendLine($"public {p.Type} {p.Name}");
        AppendLine("{");
        IncreaseIndent();
        AppendLine($"get => {p.BackingFieldName};");
        if (p.IsReadOnly)
        {
            DecreaseIndent();
            AppendLine("}");
            return;
        }

        AppendLine("set");
        AppendLine("{");
        IncreaseIndent();
        AppendLine($"if ({p.BackingFieldName} == value)");
        AppendLine("{");
        IncreaseIndent();
        AppendLine("return;");
        DecreaseIndent();
        AppendLine("}");
        AppendLine();

        if (p.BeforeChangedCallback is not null)
        {
            GenerateCallbackInlineCode(p.BeforeChangedCallback);
            AppendLine();
        }

        if (p.BroadcastOnChange)
        {
            AppendLine($"var oldValue = {p.BackingFieldName};");
        }

        var nameofName = p.Name.EnsureNameofContent();

        AppendLine($"{p.BackingFieldName} = value;");
        AppendLine($"RaisePropertyChanged({nameofName});");
        if (p.PropertyNamesToInvalidate is not null)
        {
            foreach (var propertyNameToInvalidate in p.PropertyNamesToInvalidate)
            {
                var nameofPropertyNameToInvalidate = propertyNameToInvalidate.EnsureNameofContent();

                AppendLine($"RaisePropertyChanged({nameofPropertyNameToInvalidate});");
            }
        }

        if (p.CommandNamesToInvalidate is not null)
        {
            foreach (var commandNamesToInvalidate in p.CommandNamesToInvalidate)
            {
                var commandNameToInvalidate = commandNamesToInvalidate.EnsureNoNameof();

                AppendLine($"{commandNameToInvalidate}.RaiseCanExecuteChanged();");
            }
        }

        if (p.BroadcastOnChange)
        {
            AppendLine($"Broadcast({nameofName}, oldValue, value);");
        }

        if (useIsDirty || p.UseIsDirty)
        {
            AppendLine("IsDirty = true;");
        }

        if (p.AfterChangedCallback is not null)
        {
            AppendLine();
            GenerateCallbackInlineCode(p.AfterChangedCallback);
        }

        DecreaseIndent();
        AppendLine("}");
        DecreaseIndent();
        AppendLine("}");
    }

    private void GenerateCallbackInlineCode(
        string value)
    {
        if (value.StartsWith("nameof(", StringComparison.Ordinal) &&
            value.EndsWith(")", StringComparison.Ordinal))
        {
            var valueContent = value.ExtractInnerContent();
            GenerateCallbackInlineCodeHelper(valueContent);
        }
        else
        {
            GenerateCallbackInlineCodeHelper(value);
        }
    }

    private void GenerateCallbackInlineCodeHelper(
        string valueContent)
    {
        var sa = valueContent.Split([';'], StringSplitOptions.RemoveEmptyEntries);
        foreach (var s in sa)
        {
            var line = s.Trim();
            if (line.EndsWith(");", StringComparison.Ordinal))
            {
                AppendLine(line);
            }
            else if (line.EndsWith(")", StringComparison.Ordinal))
            {
                AppendLine(line + ";");
            }
            else
            {
                AppendLine(line + "();");
            }
        }
    }

    public void GenerateToString(
        ObservableDtoViewModelToGenerate viewModelToGenerate)
    {
        AppendLine();
        AppendLine("public override string ToString()");

        if (viewModelToGenerate.HasCustomToString)
        {
            AppendLine("    => dto?.ToString() ?? base.ToString();");
        }
        else
        {
            var propertyNames = viewModelToGenerate.Properties
                .Select(p => $"{{nameof({p.Name})}}: {{{p.Name}}}")
                .ToList();

            // Add custom properties to ToString
            foreach (var customProp in viewModelToGenerate.CustomProperties)
            {
                propertyNames.Add($"{{nameof({customProp.Name})}}: {{{customProp.Name}}}");
            }

            var toStringExpression = string.Join(", ", propertyNames);

            AppendLine($"    => $\"{toStringExpression}\";");
        }
    }
}