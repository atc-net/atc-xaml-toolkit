// ReSharper disable MergeIntoPattern
namespace Atc.XamlToolkit.SourceGenerators.Extensions.Builder;

[SuppressMessage("Design", "CA1308:Teplace the call to 'ToLowerInvariant' with 'ToUpperInvariant'", Justification = "OK.")]
[SuppressMessage("Design", "MA0051:Method is too long", Justification = "OK.")]
internal static class FrameworkElementBuilderExtensions
{
    public static void GenerateStart(
        this FrameworkElementBuilder builder,
        FrameworkElementToGenerate frameworkElementToGenerate)
    {
        builder.AppendLine("// <auto-generated>");
        builder.AppendLine("#nullable enable");

        // Only WPF supports UpdateSourceTrigger
        if (frameworkElementToGenerate.XamlPlatform == XamlPlatform.Wpf &&
            frameworkElementToGenerate.DependencyPropertiesToGenerate is not null &&
            frameworkElementToGenerate.DependencyPropertiesToGenerate.Any(x => x.DefaultUpdateSourceTrigger is not null))
        {
            builder.AppendLine("using System.Windows.Data;");
        }

        if (frameworkElementToGenerate.RelayCommandsToGenerate?.Count > 0)
        {
            builder.AppendLine("using Atc.XamlToolkit.Command;");
        }

        builder.AppendLine();
        builder.AppendLine($"namespace {frameworkElementToGenerate.NamespaceName};");
        builder.AppendLine();
        builder.AppendLine(frameworkElementToGenerate.IsStatic
            ? $"{frameworkElementToGenerate.ClassAccessModifier} static partial class {frameworkElementToGenerate.ClassName}"
            : $"{frameworkElementToGenerate.ClassAccessModifier} partial class {frameworkElementToGenerate.ClassName}");
        builder.AppendLine("{");
        builder.IncreaseIndent();
    }

    public static void GenerateAttachedProperties(
        this FrameworkElementBuilder builder,
        XamlPlatform xamlPlatform,
        IEnumerable<AttachedPropertyToGenerate>? attachedPropertiesToGenerate)
    {
        if (attachedPropertiesToGenerate is null)
        {
            return;
        }

        foreach (var propertyToGenerate in attachedPropertiesToGenerate)
        {
            GenerateAttachedProperty(builder, propertyToGenerate, xamlPlatform);
        }
    }

    public static void GenerateDependencyProperties(
        this FrameworkElementBuilder builder,
        XamlPlatform xamlPlatform,
        IEnumerable<DependencyPropertyToGenerate>? dependencyPropertiesToGenerate)
    {
        if (dependencyPropertiesToGenerate is null)
        {
            return;
        }

        var propertiesToGenerate = dependencyPropertiesToGenerate.ToList();

        foreach (var propertyToGenerate in propertiesToGenerate)
        {
            GenerateDependencyProperty(builder, propertyToGenerate, xamlPlatform);
        }

        // For Avalonia, generate static constructor to register callbacks
        if (xamlPlatform == XamlPlatform.Avalonia && propertiesToGenerate.Count > 0)
        {
            var propertiesWithCallbacks = propertiesToGenerate
                .Where(p => !string.IsNullOrEmpty(p.PropertyChangedCallback))
                .ToList();

            if (propertiesWithCallbacks.Count > 0)
            {
                var className = propertiesToGenerate.First().OwnerType;
                GenerateAvaloniaStaticConstructor(builder, className, propertiesWithCallbacks);
            }
        }
    }

    public static void GenerateRoutedEvents(
        this FrameworkElementBuilder builder,
        IEnumerable<RoutedEventToGenerate>? routedEventToGenerates)
    {
        if (routedEventToGenerates is null)
        {
            return;
        }

        foreach (var routedEventToGenerate in routedEventToGenerates)
        {
            GenerateRoutedEvent(builder, routedEventToGenerate);
        }
    }

    private static void GenerateAttachedProperty(
        FrameworkElementBuilder builder,
        AttachedPropertyToGenerate p,
        XamlPlatform xamlPlatform)
    {
        GenerateDependencyPropertyHeader(builder, p, isAttached: true, xamlPlatform);
        GenerateDependencyPropertyBody(builder, p, xamlPlatform);
        GenerateClrAttachedMethods(builder, p, xamlPlatform);
    }

    private static void GenerateDependencyProperty(
        FrameworkElementBuilder builder,
        DependencyPropertyToGenerate p,
        XamlPlatform xamlPlatform)
    {
        GenerateDependencyPropertyHeader(builder, p, isAttached: false, xamlPlatform);
        GenerateDependencyPropertyBody(builder, p, xamlPlatform);
        GenerateClrDependencyProperty(builder, p, xamlPlatform);
    }

    private static void GenerateDependencyPropertyHeader(
        FrameworkElementBuilder builder,
        BaseFrameworkElementPropertyToGenerate p,
        bool isAttached,
        XamlPlatform xamlPlatform)
    {
        var registerMethod = isAttached
            ? "RegisterAttached"
            : "Register";

        // Platform-specific DependencyProperty type
        var dependencyPropertyType = xamlPlatform switch
        {
            XamlPlatform.WinUI => "Microsoft.UI.Xaml.DependencyProperty",
            XamlPlatform.Avalonia when isAttached => "Avalonia.AvaloniaProperty",
            XamlPlatform.Avalonia => $"StyledProperty<{p.Type.TrimNullableForTypeOf()}>",
            _ => "DependencyProperty", // WPF
        };

        builder.AppendLineBeforeMember();

        // Avalonia uses generic type parameters, WPF/WinUI use typeof() parameters
        if (xamlPlatform == XamlPlatform.Avalonia)
        {
            var genericParams = isAttached
                ? $"<{p.OwnerType.RemoveNullableSuffix()}, AvaloniaObject, {p.Type.TrimNullableForTypeOf()}>"
                : $"<{p.OwnerType.RemoveNullableSuffix()}, {p.Type.TrimNullableForTypeOf()}>";

            // For non-attached properties (StyledProperty), use AvaloniaProperty.Register, not StyledProperty<T>.Register
            var registrationClass = "Avalonia.AvaloniaProperty";

            builder.AppendLine(
                p.UseNewKeyword
                    ? $"public static new readonly {dependencyPropertyType} {p.Name}Property = {registrationClass}.{registerMethod}{genericParams}("
                    : $"public static readonly {dependencyPropertyType} {p.Name}Property = {registrationClass}.{registerMethod}{genericParams}(");
        }
        else
        {
            builder.AppendLine(
                p.UseNewKeyword
                    ? $"public static new readonly {dependencyPropertyType} {p.Name}Property = {dependencyPropertyType}.{registerMethod}("
                    : $"public static readonly {dependencyPropertyType} {p.Name}Property = {dependencyPropertyType}.{registerMethod}(");
        }

        builder.IncreaseIndent();

        // For Avalonia, only add comma if there's a default value (checked in body generation)
        // For WPF/WinUI, always add comma as there are more parameters
        var hasDefaultValue = p.DefaultValue is not null && !"null".Equals(p.DefaultValue);
        var needsComma = xamlPlatform != XamlPlatform.Avalonia || hasDefaultValue;

        if (isAttached || p.IsOwnerTypeStatic)
        {
            builder.AppendLine(needsComma ? $"\"{p.Name}\"," : $"\"{p.Name}\"");
        }
        else
        {
            builder.AppendLine(needsComma ? $"{p.Name.EnsureNameofContent()}," : $"{p.Name.EnsureNameofContent()}");
        }

        // Skip typeof() lines for Avalonia (it uses generics instead)
        if (xamlPlatform != XamlPlatform.Avalonia)
        {
            builder.AppendLine($"typeof({p.Type.TrimNullableForTypeOf()}),");
        }
    }

    private static void GenerateDependencyPropertyBody(
        FrameworkElementBuilder builder,
        BaseFrameworkElementPropertyToGenerate p,
        XamlPlatform xamlPlatform)
    {
        // Avalonia has a completely different registration API
        if (xamlPlatform == XamlPlatform.Avalonia)
        {
            GenerateAvaloniaPropertyBody(builder, p);
            return;
        }

        // WinUI doesn't support ValidateValueCallback, CoerceValueCallback, Flags, DefaultUpdateSourceTrigger, IsAnimationProhibited
        var isWpf = xamlPlatform == XamlPlatform.Wpf;

        if (p.HasAnyMetadata)
        {
            builder.AppendLine($"typeof({p.OwnerType.RemoveNullableSuffix()}),");

            if (string.IsNullOrEmpty(p.Flags) &&
                string.IsNullOrEmpty(p.PropertyChangedCallback) &&
                string.IsNullOrEmpty(p.CoerceValueCallback))
            {
                if (isWpf && p.HasAnyValidateValueCallback)
                {
                    if (p.DefaultValue is not null && !"null".Equals(p.DefaultValue))
                    {
                        builder.AppendLine($"new PropertyMetadata(defaultValue: {p.DefaultValue}),");
                    }
                    else
                    {
                        builder.AppendLine("new PropertyMetadata(defaultValue: null),");
                    }

                    builder.DecreaseIndent();
                    builder.AppendLine($"validateValueCallback: {p.ValidateValueCallback});");
                }
                else
                {
                    if (p.DefaultValue is not null && !"null".Equals(p.DefaultValue))
                    {
                        builder.AppendLine($"new PropertyMetadata(defaultValue: {p.DefaultValue}));");
                    }
                    else
                    {
                        builder.AppendLine("new PropertyMetadata());");
                    }

                    builder.DecreaseIndent();
                }
            }
            else
            {
                if (string.IsNullOrEmpty(p.Flags) &&
                    string.IsNullOrEmpty(p.DefaultUpdateSourceTrigger) &&
                    p.IsAnimationProhibited is null)
                {
                    if (isWpf && p.HasAnyValidateValueCallback)
                    {
                        GeneratePropertyMetadataExtended(builder, p, endWithComma: true);
                        builder.DecreaseIndent();
                        builder.AppendLine($"validateValueCallback: {p.ValidateValueCallback});");
                    }
                    else
                    {
                        GeneratePropertyMetadataExtended(builder, p, endWithComma: false);
                        builder.DecreaseIndent();
                    }
                }
                else
                {
                    // FrameworkPropertyMetadata is WPF-only
                    if (isWpf)
                    {
                        if (p.HasAnyValidateValueCallback)
                        {
                            GenerateFrameworkPropertyMetadata(builder, p, endWithComma: true);
                            builder.DecreaseIndent();
                            builder.AppendLine($"validateValueCallback: {p.ValidateValueCallback});");
                        }
                        else
                        {
                            GenerateFrameworkPropertyMetadata(builder, p, endWithComma: false);
                            builder.DecreaseIndent();
                        }
                    }
                    else
                    {
                        // For WinUI, fall back to simple PropertyMetadata
                        GeneratePropertyMetadataExtended(builder, p, endWithComma: false);
                        builder.DecreaseIndent();
                    }
                }

                builder.DecreaseIndent();
            }
        }
        else
        {
            if (isWpf && p.HasAnyValidateValueCallback)
            {
                builder.AppendLine($"typeof({p.OwnerType.RemoveNullableSuffix()}),");
                builder.DecreaseIndent();
                builder.AppendLine($"validateValueCallback: {p.ValidateValueCallback});");
            }
            else if (!isWpf)
            {
                // WinUI requires PropertyMetadata parameter even if empty
                builder.AppendLine($"typeof({p.OwnerType.RemoveNullableSuffix()}),");
                builder.AppendLine("new PropertyMetadata(default));");
                builder.DecreaseIndent();
            }
            else
            {
                // WPF without metadata
                builder.AppendLine($"typeof({p.OwnerType.RemoveNullableSuffix()}));");
                builder.DecreaseIndent();
            }
        }
    }

    private static void GeneratePropertyMetadataExtended(
        FrameworkElementBuilder builder,
        BaseFrameworkElementPropertyToGenerate p,
        bool endWithComma)
    {
        builder.AppendLine("new PropertyMetadata(");
        builder.IncreaseIndent();
        if (p.DefaultValue is not null && !"null".Equals(p.DefaultValue))
        {
            builder.AppendLine($"defaultValue: {p.DefaultValue},");
        }
        else
        {
            builder.AppendLine("defaultValue: null,");
        }

        if (string.IsNullOrEmpty(p.PropertyChangedCallback))
        {
            builder.AppendLine(
                endWithComma
                    ? $"coerceValueCallback: {p.CoerceValueCallback}),"
                    : $"coerceValueCallback: {p.CoerceValueCallback}));");
        }
        else if (string.IsNullOrEmpty(p.CoerceValueCallback))
        {
            builder.AppendLine(
                endWithComma
                    ? $"propertyChangedCallback: {p.PropertyChangedCallback}),"
                    : $"propertyChangedCallback: {p.PropertyChangedCallback}));");
        }
        else
        {
            builder.AppendLine($"propertyChangedCallback: {p.PropertyChangedCallback},");
            builder.AppendLine(
                endWithComma
                    ? $"coerceValueCallback: {p.CoerceValueCallback}),"
                    : $"coerceValueCallback: {p.CoerceValueCallback}));");
        }
    }

    private static void GenerateFrameworkPropertyMetadata(
        FrameworkElementBuilder builder,
        BaseFrameworkElementPropertyToGenerate p,
        bool endWithComma)
    {
        builder.AppendLine("new FrameworkPropertyMetadata(");
        builder.IncreaseIndent();
        if (p.DefaultValue is not null && !"null".Equals(p.DefaultValue))
        {
            builder.AppendLine($"defaultValue: {p.DefaultValue},");
        }
        else
        {
            builder.AppendLine("defaultValue: null,");
        }

        if (!string.IsNullOrEmpty(p.PropertyChangedCallback))
        {
            builder.AppendLine($"propertyChangedCallback: {p.PropertyChangedCallback},");
        }

        if (!string.IsNullOrEmpty(p.CoerceValueCallback))
        {
            builder.AppendLine($"coerceValueCallback: {p.CoerceValueCallback},");
        }

        var hasAddedLine = false;
        if (!string.IsNullOrEmpty(p.Flags))
        {
            builder.Append($"flags: {p.Flags}");
            hasAddedLine = true;
        }

        if (!string.IsNullOrEmpty(p.DefaultUpdateSourceTrigger))
        {
            if (hasAddedLine)
            {
                builder.AppendLine(",");
            }

            if (string.IsNullOrEmpty(p.CoerceValueCallback))
            {
                builder.AppendLine("coerceValueCallback: null,");
            }

            if (!p.IsAnimationProhibited.HasValue)
            {
                builder.AppendLine("isAnimationProhibited: false,");
            }

            builder.Append($"defaultUpdateSourceTrigger: {p.DefaultUpdateSourceTrigger}");
        }

        if (p.IsAnimationProhibited.HasValue)
        {
            if (hasAddedLine)
            {
                builder.AppendLine(",");
            }

            if (string.IsNullOrEmpty(p.DefaultUpdateSourceTrigger) &&
                string.IsNullOrEmpty(p.CoerceValueCallback))
            {
                builder.AppendLine("coerceValueCallback: null,");
            }

            builder.Append($"isAnimationProhibited: {p.IsAnimationProhibited.Value.ToString().ToLowerInvariant()}");
        }

        builder.AppendLine(
            endWithComma
                ? "),"
                : "));");
    }

    private static void GenerateClrDependencyProperty(
        FrameworkElementBuilder builder,
        DependencyPropertyToGenerate p,
        XamlPlatform xamlPlatform)
    {
        var elementType = xamlPlatform switch
        {
            XamlPlatform.Avalonia => "AvaloniaObject",
            _ => "DependencyObject", // WPF and WinUI
        };

        builder.AppendLine();

        if (p.IsOwnerTypeStatic)
        {
            if (!string.IsNullOrEmpty(p.Category))
            {
                builder.AppendLine($"[Category(\"{p.Category}\")]");
            }

            if (!string.IsNullOrEmpty(p.Description))
            {
                builder.AppendLine($"[Description(\"Get: {p.Description}\")]");
            }

            builder.AppendLine($"public static {p.Type} Get{p.Name}({elementType} element)");
            builder.IncreaseIndent();
            builder.AppendLine($"=> ({p.Type})element.GetValue({p.Name}Property);");
            builder.DecreaseIndent();

            builder.AppendLine();

            if (!string.IsNullOrEmpty(p.Category))
            {
                builder.AppendLine($"[Category(\"{p.Category}\")]");
            }

            if (!string.IsNullOrEmpty(p.Description))
            {
                builder.AppendLine($"[Description(\"Set: {p.Description}\")]");
            }

            builder.AppendLine($"public static void Set{p.Name}({elementType} element, {p.Type} value)");
            builder.IncreaseIndent();
            builder.AppendLine(
                p.Type.StartsWith("bool", StringComparison.Ordinal) && xamlPlatform != XamlPlatform.Avalonia
                ? $"=> element?.SetValue({p.Name}Property, BooleanBoxes.Box(value));"
                : $"=> element?.SetValue({p.Name}Property, value);");
            builder.DecreaseIndent();
        }
        else
        {
            if (!string.IsNullOrEmpty(p.Category))
            {
                builder.AppendLine($"[Category(\"{p.Category}\")]");
            }

            if (!string.IsNullOrEmpty(p.Description))
            {
                builder.AppendLine($"[Description(\"{p.Description}\")]");
            }

            builder.AppendLine(
                p.UseNewKeyword
                    ? $"public new {p.Type} {p.Name}"
                    : $"public {p.Type} {p.Name}");
            builder.AppendLine("{");
            builder.IncreaseIndent();
            builder.AppendLine($"get => ({p.Type})GetValue({p.Name}Property);");
            if (!p.IsReadOnly)
            {
                builder.AppendLine(
                    p.Type.StartsWith("bool", StringComparison.Ordinal) && xamlPlatform != XamlPlatform.Avalonia
                    ? $"set => SetValue({p.Name}Property, BooleanBoxes.Box(value));"
                    : $"set => SetValue({p.Name}Property, value);");
            }

            builder.DecreaseIndent();
            builder.AppendLine("}");
        }
    }

    private static void GenerateClrAttachedMethods(
        FrameworkElementBuilder builder,
        AttachedPropertyToGenerate p,
        XamlPlatform xamlPlatform)
    {
        var elementType = xamlPlatform switch
        {
            XamlPlatform.Avalonia => "AvaloniaObject",
            _ => "DependencyObject", // WPF and WinUI
        };

        builder.AppendLine();

        if (!string.IsNullOrEmpty(p.Category))
        {
            builder.AppendLine($"[Category(\"{p.Category}\")]");
        }

        if (!string.IsNullOrEmpty(p.Description))
        {
            builder.AppendLine($"[Description(\"Get: {p.Description}\")]");
        }

        builder.AppendLine($"public static {p.Type} Get{p.Name}({elementType} element)");
        builder.IncreaseIndent();
        builder.AppendLine($"=> ({p.Type})element.GetValue({p.Name}Property);");
        if (!p.IsReadOnly)
        {
            builder.DecreaseIndent();

            builder.AppendLine();

            if (!string.IsNullOrEmpty(p.Category))
            {
                builder.AppendLine($"[Category(\"{p.Category}\")]");
            }

            if (!string.IsNullOrEmpty(p.Description))
            {
                builder.AppendLine($"[Description(\"Set: {p.Description}\")]");
            }

            builder.AppendLine($"public static void Set{p.Name}({elementType} element, {p.Type} value)");
            builder.IncreaseIndent();
            builder.AppendLine(
                p.Type.StartsWith("bool", StringComparison.Ordinal) && xamlPlatform != XamlPlatform.Avalonia
                ? $"=> element?.SetValue({p.Name}Property, BooleanBoxes.Box(value));"
                : $"=> element?.SetValue({p.Name}Property, value);");
        }

        builder.DecreaseIndent();
    }

    private static void GenerateRoutedEvent(
        FrameworkElementBuilder builder,
        RoutedEventToGenerate re)
    {
        builder.AppendLineBeforeMember();
        builder.AppendLine($"public static readonly RoutedEvent {re.Name}Event = EventManager.RegisterRoutedEvent(");
        builder.IncreaseIndent();
        builder.AppendLine($"name: nameof({re.Name}),");
        builder.AppendLine(string.IsNullOrEmpty(re.RoutingStrategy)
            ? "routingStrategy: RoutingStrategy.Bubble,"
            : $"routingStrategy: RoutingStrategy.{re.RoutingStrategy},");
        builder.AppendLine($"handlerType: typeof({re.HandlerTypeName}),");
        builder.AppendLine($"ownerType: typeof({re.OwnerType}));");
        builder.DecreaseIndent();
        builder.AppendLine();
        builder.AppendLine($"public event {re.HandlerTypeName} {re.Name}");
        builder.AppendLine("{");
        builder.IncreaseIndent();
        builder.AppendLine($"add => AddHandler({re.Name}Event, value);");
        builder.AppendLine($"remove => RemoveHandler({re.Name}Event, value);");
        builder.DecreaseIndent();
        builder.AppendLine("}");
    }

    private static void GenerateAvaloniaPropertyBody(
        FrameworkElementBuilder builder,
        BaseFrameworkElementPropertyToGenerate p)
    {
        //// Avalonia registration format is much simpler:
        //// Register<TOwner, TValue>(name, defaultValue)
        //// RegisterAttached<TOwner, THost, TValue>(name, defaultValue)

        var hasDefaultValue = p.DefaultValue is not null && !"null".Equals(p.DefaultValue);

        builder.AppendLine(hasDefaultValue ? $"defaultValue: {p.DefaultValue});" : ");");

        builder.DecreaseIndent();

        //// For PropertyChangedCallback, Avalonia uses property changed pattern differently
        //// The callback is defined by the user directly in the class, not in the registration
        //// So we just skip generating PropertyMetadata for Avalonia
    }

    private static void GenerateAvaloniaStaticConstructor(
        FrameworkElementBuilder builder,
        string className,
        IEnumerable<DependencyPropertyToGenerate> propertiesWithCallbacks)
    {
        builder.AppendLine();
        builder.AppendLine($"static {className}()");
        builder.AppendLine("{");
        builder.IncreaseIndent();

        foreach (var property in propertiesWithCallbacks)
        {
            builder.AppendLine($"{property.Name}Property.Changed.AddClassHandler<{className}>({property.PropertyChangedCallback});");
        }

        builder.DecreaseIndent();
        builder.AppendLine("}");
    }
}