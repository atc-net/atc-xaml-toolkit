namespace Atc.XamlToolkit.SourceGenerators.Extensions.Builder;

[SuppressMessage("Design", "MA0051:Method is too long", Justification = "OK.")]
internal static class ViewModelBuilderExtensions
{
    public static void GenerateStart(
        this ViewModelBuilder builder,
        ViewModelToGenerate viewModelToGenerate)
    {
        builder.AppendLine("// <auto-generated>");
        builder.AppendLine("#nullable enable");
        if (viewModelToGenerate.RelayCommandsToGenerate?.Count > 0)
        {
            builder.AppendLine("using Atc.XamlToolkit.Command;");
        }

        builder.AppendLine();
        builder.AppendLine($"namespace {viewModelToGenerate.NamespaceName};");
        builder.AppendLine();
        builder.AppendLine($"{viewModelToGenerate.ClassAccessModifier} partial class {viewModelToGenerate.ClassName}");
        builder.AppendLine("{");
        builder.IncreaseIndent();
    }

    public static void GenerateProperties(
        this ViewModelBuilder builder,
        IEnumerable<ObservablePropertyToGenerate>? propertiesToGenerate)
    {
        if (propertiesToGenerate is null)
        {
            return;
        }

        foreach (var propertyToGenerate in propertiesToGenerate)
        {
            GenerateProperty(builder, propertyToGenerate);
        }
    }

    private static void GenerateProperty(
        ViewModelBuilder builder,
        ObservablePropertyToGenerate p)
    {
        builder.AppendLineBeforeMember();
        builder.AppendLine($"public {p.Type} {p.Name}");
        builder.AppendLine("{");
        builder.IncreaseIndent();
        builder.AppendLine($"get => {p.BackingFieldName};");
        if (p.IsReadOnly)
        {
            builder.DecreaseIndent();
            builder.AppendLine("}");
            return;
        }

        builder.AppendLine("set");
        builder.AppendLine("{");
        builder.IncreaseIndent();
        builder.AppendLine($"if ({p.BackingFieldName} == value)");
        builder.AppendLine("{");
        builder.IncreaseIndent();
        builder.AppendLine("return;");
        builder.DecreaseIndent();
        builder.AppendLine("}");
        builder.AppendLine();
        if (p.BeforeChangedCallback is not null)
        {
            GenerateCallbackInlineCode(builder, p.BeforeChangedCallback);
            builder.AppendLine();
        }

        if (p.BroadcastOnChange)
        {
            builder.AppendLine($"var oldValue = {p.BackingFieldName};");
        }

        var nameofName = p.Name.EnsureNameofContent();

        builder.AppendLine($"{p.BackingFieldName} = value;");
        builder.AppendLine($"RaisePropertyChanged({nameofName});");
        if (p.PropertyNamesToInvalidate is not null)
        {
            foreach (var propertyNameToInvalidate in p.PropertyNamesToInvalidate)
            {
                var nameofPropertyNameToInvalidate = propertyNameToInvalidate.EnsureNameofContent();

                builder.AppendLine($"RaisePropertyChanged({nameofPropertyNameToInvalidate});");
            }
        }

        if (p.CommandNamesToInvalidate is not null)
        {
            foreach (var commandNamesToInvalidate in p.CommandNamesToInvalidate)
            {
                var commandNameToInvalidate = commandNamesToInvalidate.EnsureNoNameof();

                builder.AppendLine($"{commandNameToInvalidate}.RaiseCanExecuteChanged();");
            }
        }

        if (p.BroadcastOnChange)
        {
            builder.AppendLine($"Broadcast({nameofName}, oldValue, value);");
        }

        if (p.UseIsDirty)
        {
            builder.AppendLine("IsDirty = true;");
        }

        if (p.AfterChangedCallback is not null)
        {
            builder.AppendLine();
            GenerateCallbackInlineCode(builder, p.AfterChangedCallback);
        }

        builder.DecreaseIndent();
        builder.AppendLine("}");
        builder.DecreaseIndent();
        builder.AppendLine("}");
    }

    private static void GenerateCallbackInlineCode(
        ViewModelBuilder builder,
        string value)
    {
        if (value.StartsWith("nameof(", StringComparison.Ordinal) &&
            value.EndsWith(")", StringComparison.Ordinal))
        {
            var valueContent = value.ExtractInnerContent();
            GenerateCallbackInlineCodeHelper(builder, valueContent);
        }
        else
        {
            GenerateCallbackInlineCodeHelper(builder, value);
        }
    }

    private static void GenerateCallbackInlineCodeHelper(
        ViewModelBuilder builder,
        string valueContent)
    {
        // Check if this is multi-line code (contains line breaks)
        if (valueContent.Contains('\n') || valueContent.Contains('\r'))
        {
            GenerateMultiLineCallbackCode(builder, valueContent);
        }
        else
        {
            GenerateSingleLineCallbackCode(builder, valueContent);
        }
    }

    private static void GenerateMultiLineCallbackCode(
        ViewModelBuilder builder,
        string valueContent)
    {
        // For multi-line code, output as-is with proper semicolon handling
        // Trim to remove any leading/trailing newlines from the raw string literal
        valueContent = valueContent.Trim('\r', '\n');

        // Then trim any trailing whitespace to remove indentation-only final lines
        valueContent = valueContent.TrimEnd();

        var lines = valueContent
            .Split(["\r\n", "\r", "\n"], StringSplitOptions.None)
            .Where(l => l.Trim() != "\"\"")
            .ToList();

        // Find the minimum number of leading whitespace characters across all non-empty lines
        var leadingSpacesCount = lines
            .Where(l => !string.IsNullOrWhiteSpace(l))
            .Select(l => l.Length - l.TrimStart().Length)
            .DefaultIfEmpty(0)
            .Min();

        // Track the last non-empty line for semicolon handling
        var lastNonEmptyLine = lines.Last(l => !string.IsNullOrWhiteSpace(l));

        foreach (var line in lines)
        {
            if (string.IsNullOrWhiteSpace(line))
            {
                builder.AppendLine();
                continue;
            }

            // Remove the leading spaces count from the start of the line
            var adjustedLine = line.Length >= leadingSpacesCount
                ? line.Substring(leadingSpacesCount)
                : line.TrimStart();

            var isLastLine = line == lastNonEmptyLine;

            if (isLastLine && !adjustedLine.TrimEnd().EndsWith(";", StringComparison.Ordinal))
            {
                builder.AppendLine(adjustedLine.TrimEnd() + ";");
            }
            else
            {
                builder.AppendLine(adjustedLine);
            }
        }
    }

    private static void GenerateSingleLineCallbackCode(
        ViewModelBuilder builder,
        string valueContent)
    {
        var sa = valueContent.Split([';'], StringSplitOptions.RemoveEmptyEntries);
        foreach (var s in sa)
        {
            var line = s.Trim();
            if (line.EndsWith(");", StringComparison.Ordinal))
            {
                builder.AppendLine(line);
            }
            else if (line.EndsWith(")", StringComparison.Ordinal))
            {
                builder.AppendLine(line + ";");
            }
            else
            {
                builder.AppendLine(line + "();");
            }
        }
    }
}